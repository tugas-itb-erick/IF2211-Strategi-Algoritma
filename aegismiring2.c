#pragma config(StandardModel, "EV3_REMBOT")
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/* Tugas Besar IF2211 Strategi Algortima 2 */
/* Topik : DFS dan BFS */
/* Kelompok 34 - Aegis */
/* Anggota :
 * Gisela Supardi - 13515009
 * Erick Wijaya   - 13515057
 * Audry Nyonata  - 13515087
 */

#include "list/queue/queue.h"
#include "list/queue/queue.c"
#include "list/stack/stack.h"
#include "list/stack/stack.c"
#include "list/list.c"

/* Motors Procedure */
void MoveForward();
// Simple moving forward procedure
void MoveForwardTimed(int t);
// Move forward in t milliseconds
void MoveBackward();
// Simple move backward procedure
void MoveBackwardTimed(int t);
// Move backward in t milliseconds
void FollowBlackLine();
// Follow black line
void Turn(int dir);
// Turn depends on dir (direction)
// dir=1 -> turn left
// dir=2 -> turn right
// dir=3 -> turn behind
void TurnTimed(int dir, int t);
// Turn to dir direction in t milliseconds
void CheckPath(bool *l, bool *m, bool *r);
// initial state: robot is located on green tile
// check if left, middle, and right has accesible path
// output true if has accesible path
void BackToStart(Stack * S);
// initial state: stack is not empty
// bring the robot back to blue tile from yellow tile
void DFS();
// depth-first search
void BFS();
// breath-first search

/* Color Predicate */
bool IsWhite();
bool IsBlack();
bool IsBlue();
bool IsGreen();
bool IsRed();
bool IsYellow();

/* Body */
void MoveForward(){
	setMotorSpeed(leftMotor, 50);
	setMotorSpeed(rightMotor, 50);
}

void MoveForwardTimed(int t){
	setMotorSpeed(leftMotor, 30);
	setMotorSpeed(rightMotor, 30);
	sleep(t);
}

void MoveBackward(){
	setMotorSpeed(leftMotor, -50);
	setMotorSpeed(rightMotor, -50);
}

void MoveBackwardTimed(int t){
	setMotorSpeed(leftMotor, -30);
	setMotorSpeed(rightMotor, -30);
	sleep(t);
}

void FollowBlackLine(){
  if(IsWhite()){
    // counter-steer right:
    motor[leftMotor]  = 15;
    motor[rightMotor] = 55;
  }
  // sensor sees dark:
  else{
    // counter-steer left:
    motor[leftMotor]  = 55;
    motor[rightMotor] = 15;
  }
}

void Turn(int dir){
	int speed = 30;

	resetGyro(gyroSensor);
	if (dir == 1){
		setMotorSpeed(leftMotor, -speed);
		setMotorSpeed(rightMotor, speed);
		repeatUntil(getGyroDegrees(gyroSensor) <= -89){}
	}
	else if (dir == 2){
		setMotorSpeed(leftMotor, speed);
		setMotorSpeed(rightMotor, -speed);
		repeatUntil(getGyroDegrees(gyroSensor) >= 89){}
	}
	else{
		setMotorSpeed(leftMotor, speed);
		setMotorSpeed(rightMotor, -speed);
		repeatUntil(getGyroDegrees(gyroSensor) >= 179){}
	}
	setMotorSpeed(leftMotor, 0);
	setMotorSpeed(rightMotor, 0);
}

void TurnTimed(int dir, int t){
	int speed = 30;

	resetGyro(gyroSensor);
	if (dir == 1){
		setMotorSpeed(leftMotor, -speed);
		setMotorSpeed(rightMotor, speed);
	}
	else if (dir == 2){
		setMotorSpeed(leftMotor, speed);
		setMotorSpeed(rightMotor, -speed);
	}
	else{
		setMotorSpeed(leftMotor, speed);
		setMotorSpeed(rightMotor, -speed);
	}
	sleep(t);
	setMotorSpeed(leftMotor, 0);
	setMotorSpeed(rightMotor, 0);
}

bool IsWhite(){
	return (getColorName(colorSensor) == colorWhite);
}

bool IsBlack(){
	return (getColorName(colorSensor) == colorBlack);
}

bool IsBlue(){
	return (getColorName(colorSensor) == colorBlue);
}

bool IsGreen(){
	return (getColorName(colorSensor) == colorGreen);
}

bool IsRed(){
	return (getColorName(colorSensor) == colorRed);
}

bool IsYellow(){
	return (getColorName(colorSensor) == colorYellow);
}

void CheckPath(bool *l, bool *m, bool *r){
	// check left
	MoveForwardTimed(700);
	Turn(1);
	if (IsBlack())
		*l = true;
	Turn(2);
	// check mid
	MoveForwardTimed(1000);
	TurnTimed(1, 250);
	if (IsBlack())
		*m = true;
	TurnTimed(3, 250);
	// check right
	MoveBackwardTimed(300);
	Turn(2);
	MoveForwardTimed(500);
	if (IsBlack())
		*r = true;
	MoveBackwardTimed(500);
	Turn(1);
	// back to original position
	MoveBackwardTimed(700);
}

void BackToStart(Stack * S){
	int top;

	while (true){
		FollowBlackLine();
		if (!IsBlack()){
			if (IsBlue() && !IsBlack()){
				break;
			}

			else if (IsGreen()){
				MoveForwardTimed(700);
				if (!IsStackEmpty(S)){
					Pop(S, &top);
					if (top == 1)
						Turn(2);
					else if (top == 3)
						Turn(1);
					MoveForwardTimed(700);
				}
			}
		}
	}
}

void DFS(){
	int r, g, b;
	int i;
	int lv = -1;
	bool v_left[MAX]; // visited array
	bool v_right[MAX]; // visited array
	bool v_mid[MAX]; // visited array
	bool dead_end = false;
	int top;

	Stack S;
	CreateStack(&S);

	for(i=0; i<MAX; i++){
		v_left[i] = false;
		v_right[i] = false;
		v_mid[i] = false;
	}

	while(true){

		displayCenteredTextLine(1, "Aegis The Maze Solver");
		getColorRGB(colorSensor, r, g, b);
		displayString(3, "Color: %d  %d  %d   ", r, g, b);
		if (lv >= 0)
			displayString(4, "Level: %d", lv);
		else
			displayString(4, "         ", lv);

		FollowBlackLine();

		if (!IsBlack()){
			if (IsGreen()){
				displayCenteredTextLine(14, "                   ");

				if (!dead_end){
					++lv;
					displayString(4, "Level: %d", lv);

					CheckPath(&v_left[lv], &v_mid[lv], &v_right[lv]);

					// displayString(5, "Path Found: %d %d %d", v_left[lv], v_mid[lv], v_right[lv]);

					if (v_left[lv]){
						Turn(1);
						v_left[lv] = false;
						Push(&S, 1);
					}else if (v_mid[lv]){
						MoveForwardTimed(800);
						v_mid[lv] = false;
						Push(&S, 2);
					}else if (v_right[lv]){
						Turn(2);
						v_right[lv] = false;
						Push(&S, 3);
					}
								if (v_left[lv] && !v_mid[lv] && !v_right[lv]){
									v_right[lv] = true;
								} else if (!v_left[lv] && !v_mid[lv] && !v_right[lv]){
									Turn(1);
									Push(&S, 1);
									v_right[lv] = true;
								} else if (!v_left[lv] && !v_mid[lv] && v_right[lv]){
									int tes;
									Pop(&S, &tes);
									Push(&S, 1);
									Turn(1); Turn(400);
									MoveForwardTimed(500);
								}

					for(i = 0; i <= lv; i++){
						displayString(5+i, "(%d) Branching to %d", i, Info(S, i));
					}

				}

				else{
					dead_end = false;
					Pop(&S, &top);
					// displayCenteredTextLine(5, "Top : %d", top);
					MoveForwardTimed(800);

					if (top == 1){
						if (v_mid[lv]){
							Turn(1);
							v_mid[lv] = false;
							Push(&S, 2);
						}else if (v_right[lv]){
							MoveForwardTimed(800);
							v_right[lv] = false;
							Push(&S, 3);
						}else{
							Turn(2); // backtrack
							--lv;
							dead_end = true;
						}
					}
					else if (top == 2){
						if (v_right[lv]){
							Turn(1);
							v_right[lv] = false;
							Push(&S, 3);
						}else{
							MoveForwardTimed(800); // backtrack
							--lv;
							dead_end = true;
						}
					}
					else{ // top == 3;
						Turn(1); // backtrack
						--lv;
						dead_end = true;
					}

					for(i = 0; i <= lv; i++){
						displayString(5+i, "(%d) Branching to %d", i, Info(S, i));
					}

					if (dead_end){
						displayString(5+lv+1, "                     ");
						displayCenteredTextLine(14, "Backtracking...");
					}

				}


			}
			else if (IsRed()){
				displayCenteredTextLine(14, "Dead End");
				Turn(3);
				displayCenteredTextLine(14, "                   ");
				dead_end = true;
			}

			else if ((IsBlue() || IsYellow()) && !IsBlack()){
				break;
			}

		}

	}

	if (IsYellow()){
		displayCenteredTextLine(3, "Extinguishing Fire");
		Turn(3); Turn(3); Turn(3);
		displayCenteredTextLine(3, "                     ");
		displayString(4, "Solution:   ");
		displayCenteredTextLine(3, "Back To Start");
		BackToStart(&S);
		eraseDisplay();
		displayCenteredBigTextLine(2, "DFS Clear");
	}
	else if (IsBlue()){
		eraseDisplay();
		displayCenteredBigTextLine(3, "Fire Not Found");
	}


}

List L[10];

void BFS(){
	int r, g, b;
	int i;
	int lv;
	int max_lv;
	bool v_left[MAX]; // visited array
	bool v_right[MAX]; // visited array
	bool v_mid[MAX]; // visited array
	bool dead_end;
	bool solution = false;
	bool everGreen;
	int top;
	Stack S;
	CreateStack(&S);

	for(i=0; i<MAX; i++){
		v_left[i] = false;
		v_right[i] = false;
		v_mid[i] = false;
	}

	int idx[10];
	for(i=0; i<10; i++)
		CreateList(&L[i]);

	for(max_lv = 1; max_lv < 10; ++max_lv){
		everGreen = false;

		if (solution)
			break;

		for(i=0; i<10; i++)
			idx[i] = -1;

		lv = -1;
		dead_end = false;

		// displayCenteredBigTextLine(5, "%d", max_lv);

		while(true){

			displayCenteredTextLine(1, "Aegis The Maze Solver");
			getColorRGB(colorSensor, r, g, b);
			displayString(3, "Color: %d  %d  %d   ", r, g, b);
			if (lv >= 0)
				displayString(4, "Level: %d", lv);
			else
				displayString(4, "         ", lv);

			FollowBlackLine();

			if (!IsBlack()){
				if (IsGreen()){

					if (!dead_end){
						++lv;
						displayString(4, "Level: %d", lv);

						if (lv < max_lv){

							CheckPath(&v_left[lv], &v_mid[lv], &v_right[lv]);

							// displayString(5, "Path Found: %d %d %d", v_left[lv], v_mid[lv], v_right[lv]);

							++idx[lv];
							if (lv == max_lv-1){

								if (v_left[lv]){
									Turn(1);
									v_left[lv] = false;
									Push(&S, 1);
								}else if (v_mid[lv]){
									MoveForwardTimed(800);
									v_mid[lv] = false;
									Push(&S, 2);
								}else if (v_right[lv]){
									Turn(2);
									v_right[lv] = false;
									Push(&S, 3);
								}

								if (v_left[lv] && !v_mid[lv] && !v_right[lv]){
									v_right[lv] = true;
								} else if (!v_left[lv] && !v_mid[lv] && !v_right[lv]){
									Turn(1);
									Push(&S, 1);
									v_right[lv] = true;
								} else if (!v_left[lv] && !v_mid[lv] && v_right[lv]){
									int tes;
									Pop(&S, &tes);
									Push(&S, 1);
									Turn(1); Turn(400);
									MoveForwardTimed(500);
								}

							}
							else{
								if (v_left[lv] && !L[idx[lv]]){
									Turn(1);
									v_left[lv] = false;
									Push(&S, 1);
								}else if (v_mid[lv] && !L[idx[lv]]){
									MoveForwardTimed(800);
									v_mid[lv] = false;
									Push(&S, 2);
								}else if (!L[idx[lv]]){
									Turn(2);
									v_right[lv] = false;
									Push(&S, 3);
								}
								if (v_left[lv] && L[idx[lv]])
									v_left[lv] = false;
								if (v_mid[lv] && L[idx[lv]])
									v_mid[lv] = false;
								if (v_right[lv] && L[idx[lv]])
									v_right[lv] = false;


							}

							for(i = 0; i <= lv; i++){
								displayString(5+i, "(%d) Branching to %d", i, Info(S, i));
							}
						}

						else{
							everGreen = true;

							displayCenteredTextLine(14, "Backtracking...");
							Turn(3);
							displayCenteredTextLine(14, "        ");
							dead_end = true;
							--lv;

							InsertLast(&L[lv], 0);
							// ++idx[lv];
						}

					}

					else{
						dead_end = false;
						Pop(&S, &top);
						// displayCenteredTextLine(5, "Top : %d", top);
						MoveForwardTimed(800);

						if (top == 1){
							if (v_mid[lv]){
								Turn(1);
								v_mid[lv] = false;
								Push(&S, 2);
							}else if (v_right[lv]){
								MoveForwardTimed(800);
								v_right[lv] = false;
								Push(&S, 3);
							}else{
								Turn(2); // backtrack
								--lv;
								dead_end = true;
							}
						}
						else if (top == 2){
							if (v_right[lv]){
								Turn(1);
								v_right[lv] = false;
								Push(&S, 3);
							}else{
								MoveForwardTimed(800); // backtrack
								--lv;
								dead_end = true;
							}
						}
						else{ // top == 3;
							Turn(1); // backtrack
							--lv;
							dead_end = true;
						}

						for(i = 0; i <= lv; i++){
							displayString(5+i, "(%d) Branching to %d", i, Info(S, i));
						}

						if (dead_end){
							displayString(5+lv+1, "                     ");
						}

					}


				}
				else if (IsRed()){
					displayCenteredTextLine(14, "Dead End");
					Turn(3);
					displayCenteredTextLine(14, "        ");
					dead_end = true;

					InsertLast(&L[lv], 1);
					// ++idx[lv];
				}

				else if ((IsBlue() || IsYellow()) && !IsBlack()){
					solution = true;
					break;
				}

			}

			if ((lv == -1) && (dead_end) && everGreen){
				TurnTimed(2, 200);
				MoveForwardTimed(1500);
				Turn(3);
				TurnTimed(1, 100);
				break;
			}

		}

		if (!everGreen){
			while (!IsBlue())
				FollowBlackLine();
			break;
		}

		if (solution)
			break;

	}

	motor[leftMotor] = 0;
	motor[rightMotor] = 0;

	if (IsYellow()){
		displayCenteredTextLine(3, "Extinguishing Fire");
		Turn(3); Turn(3); Turn(3);
		displayCenteredTextLine(3, "                     ");
		displayString(4, "Solution:   ");
		displayCenteredTextLine(3, "Back To Start");
		BackToStart(&S);
		eraseDisplay();
		displayCenteredBigTextLine(2, "BFS Clear");
	}
	else if (IsBlue()){
		eraseDisplay();
		displayCenteredBigTextLine(3, "Fire Not Found");
	}

}

/* Main Program Here*/
task main()
{
	// Display Robot Name
	displayCenteredTextLine(1, "Aegis The Maze Solver");

	// Initial Move
	while (!IsBlack())
		MoveForward();
	MoveForwardTimed(500);

	// Start DFS
	DFS();

	// Stop Robot for 2000ms
	motor[leftMotor] = 0;
	motor[rightMotor] = 0;
	sleep(2000);

	// Prepare Robot Position to do BFS
	eraseDisplay();
	displayCenteredTextLine(1, "Aegis The Maze Solver");
	Turn(3);

	// Start BFS
	BFS();

}
