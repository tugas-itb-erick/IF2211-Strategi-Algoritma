#pragma config(StandardModel, "EV3_REMBOT")
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/* Tugas Besar IF2211 Strategi Algortima 2 */
/* Topik : DFS dan BFS */
/* Kelompok 34 - Aegis */
/* Anggota :
 * Gisela Supardi - 13515009
 * Erick Wijaya   - 13515057
 * Audry Nyonata  - 13515087
 */

#include "list/queue/queue.h"
#include "list/queue/queue.c"
#include "list/stack/stack.h"
#include "list/stack/stack.c"
#include "list/list.c"

/* Aksi Bergerak */
void MoveForward();
void MoveForwardTimed(int t);
void MoveBackward();
void MoveBackwardTimed(int t);
void FollowBlackLine();
void Turn(int dir);
void TurnTimed(int dir, int t);
void CheckPath(bool *l, bool *m, bool *r);
void BackToStart(Stack * S);
void DFS(Stack * S);
void BFS(Queue * Q);

/* Predikat Warna */
bool IsWhite();
bool IsBlack();
bool IsBlue();
bool IsGreen();
bool IsRed();
bool IsYellow();

/* Realisasi */
void MoveForward(){
	setMotorSpeed(leftMotor, 50);
	setMotorSpeed(rightMotor, 50);
}

void MoveForwardTimed(int t){
	setMotorSpeed(leftMotor, 30);
	setMotorSpeed(rightMotor, 30);
	sleep(t);
}

void MoveBackward(){
	setMotorSpeed(leftMotor, -50);
	setMotorSpeed(rightMotor, -50);
}

void MoveBackwardTimed(int t){
	setMotorSpeed(leftMotor, -30);
	setMotorSpeed(rightMotor, -30);
	sleep(t);
}

void FollowBlackLine(){
  if(IsWhite()){
    // counter-steer right:
    motor[leftMotor]  = 15;
    motor[rightMotor] = 55;
  }
  // sensor sees dark:
  else{
    // counter-steer left:
    motor[leftMotor]  = 55;
    motor[rightMotor] = 15;
  }
}

void Turn(int dir){
	int speed = 30;

	resetGyro(gyroSensor);
	if (dir == 1){
		setMotorSpeed(leftMotor, -speed);
		setMotorSpeed(rightMotor, speed);
		repeatUntil(getGyroDegrees(gyroSensor) <= -89){}
	}
	else if (dir == 2){
		setMotorSpeed(leftMotor, speed);
		setMotorSpeed(rightMotor, -speed);
		repeatUntil(getGyroDegrees(gyroSensor) >= 89){}
	}
	else{
		setMotorSpeed(leftMotor, speed);
		setMotorSpeed(rightMotor, -speed);
		repeatUntil(getGyroDegrees(gyroSensor) >= 179){}
	}
	setMotorSpeed(leftMotor, 0);
	setMotorSpeed(rightMotor, 0);
}

void TurnTimed(int dir, int t){
	int speed = 30;

	resetGyro(gyroSensor);
	if (dir == 1){
		setMotorSpeed(leftMotor, -speed);
		setMotorSpeed(rightMotor, speed);
	}
	else if (dir == 2){
		setMotorSpeed(leftMotor, speed);
		setMotorSpeed(rightMotor, -speed);
	}
	else{
		setMotorSpeed(leftMotor, speed);
		setMotorSpeed(rightMotor, -speed);
	}
	sleep(t);
	setMotorSpeed(leftMotor, 0);
	setMotorSpeed(rightMotor, 0);
}

bool IsWhite(){
	return (getColorName(colorSensor) == colorWhite);
}

bool IsBlack(){
	return (getColorName(colorSensor) == colorBlack);
}

bool IsBlue(){
	return (getColorName(colorSensor) == colorBlue);
}

bool IsGreen(){
	return (getColorName(colorSensor) == colorGreen);
}

bool IsRed(){
	return (getColorName(colorSensor) == colorRed);
}

bool IsYellow(){
	return (getColorName(colorSensor) == colorYellow);
}

void CheckPath(bool *l, bool *m, bool *r){
	// check left
	MoveForwardTimed(700);
	Turn(1);
	if (IsBlack())
		*l = true;
	Turn(2);
	// check mid
	MoveForwardTimed(1000);
	TurnTimed(1, 300);
	if (IsBlack())
		*m = true;
	TurnTimed(3, 300);
	// check right
	MoveBackwardTimed(300);
	Turn(2);
	MoveForwardTimed(500);
	if (IsBlack())
		*r = true;
	MoveBackwardTimed(500);
	Turn(1);
	// back to original position
	MoveBackwardTimed(700);
}

void BackToStart(Stack * S){
	int top;

	while (true){
		FollowBlackLine();
		if (!IsBlack()){
			if (IsBlue() && !IsBlack()){
				break;
			}

			else if (IsGreen()){
				MoveForwardTimed(700);
				if (!IsStackEmpty(S)){
					Pop(S, &top);
					if (top == 1)
						Turn(2);
					else if (top == 3)
						Turn(1);
					MoveForwardTimed(700);
				}
			}
		}
	}
}

void DFS(Stack * S){
	int r, g, b;
	int i;
	int lv = -1;
	bool v_left[MAX]; // visited array
	bool v_right[MAX]; // visited array
	bool v_mid[MAX]; // visited array
	bool dead_end = false;
	int top;

	for(i=0; i<MAX; i++){
		v_left[i] = false;
		v_right[i] = false;
		v_mid[i] = false;
	}

	while(true){

		displayCenteredTextLine(1, "Aegis The Maze Solver");
		getColorRGB(colorSensor, r, g, b);
		displayString(3, "Color: %d  %d  %d   ", r, g, b);
		if (lv >= 0)
			displayString(4, "Level: %d", lv);
		else
			displayString(4, "         ", lv);

		FollowBlackLine();

		if (!IsBlack()){
			if (IsGreen()){

				if (!dead_end){
					++lv;
					displayString(4, "Level: %d", lv);

					CheckPath(&v_left[lv], &v_mid[lv], &v_right[lv]);

					displayString(6, "Path Found: %d %d %d", v_left[lv], v_mid[lv], v_right[lv]);

					if (v_left[lv]){
						Turn(1);
						v_left[lv] = false;
						Push(S, 1);
					}else if (v_mid[lv]){
						MoveForwardTimed(800);
						v_mid[lv] = false;
						Push(S, 2);
					}else{
						Turn(2);
						v_right[lv] = false;
						Push(S, 3);
					}

				}

				else{
					dead_end = false;
					Pop(S, &top);
					// displayCenteredTextLine(5, "Top : %d", top);
					MoveForwardTimed(800);

					if (top == 1){
						if (v_mid[lv]){
							Turn(1);
							v_mid[lv] = false;
							Push(S, 2);
						}else if (v_right[lv]){
							MoveForwardTimed(800);
							v_right[lv] = false;
							Push(S, 3);
						}else{
							Turn(2); // backtrack
							--lv;
							dead_end = true;
						}
					}
					else if (top == 2){
						if (v_right[lv]){
							Turn(1);
							v_right[lv] = false;
							Push(S, 3);
						}else{
							MoveForwardTimed(800); // backtrack
							--lv;
							dead_end = true;
						}
					}
					else{ // top == 3;
						Turn(1); // backtrack
						--lv;
						dead_end = true;
					}

				}


			}
			else if (IsRed()){
				displayCenteredTextLine(8, "Dead End");
				Turn(3);
				displayCenteredTextLine(8, "        ");
				dead_end = true;
			}

			else if ((IsBlue() || IsYellow()) && !IsBlack()){
				break;
			}

		}

	}

	if (IsYellow()){
		displayCenteredBigTextLine(3, "Extinguishing Fire");
		Turn(3); Turn(3); Turn(3);
		BackToStart(S);
	}
	else if (IsBlue()){
		displayCenteredBigTextLine(3, "Fire Not Found");
	}

}

void BFS(Queue * Q){
	int node = -1;
	int head;
	int r, g, b;
	Queue Qn;
	CreateQueue(&Qn);

	while(true){
		FollowBlackLine();
		eraseDisplay();

		getColorRGB(colorSensor, r, g, b);
		displayCenteredTextLine(8, "%d %d %d", r, g, b);

		if (!IsBlack()){
			if (IsGreen()){
				++node;
				Push_Back(&Qn, node);
				bool l, m, r;

				CheckPath(&l, &m, &r);
				if (l)
					Push_Back(Q, 1);
				if (m)
					Push_Back(Q, 2);
				if (r)
					Push_Back(Q, 3);

				Pop_Head(Q, &head);

			}

			else if (IsRed()){
				Turn(3);
			}

			else if ((IsBlue() || IsYellow()) && !IsBlack()){
				break;
			}
		}
	}

}

/* Main Program Here*/
task main()
{
	Stack S;
	CreateStack(&S);
	Queue Q;
	CreateQueue(&Q);

	displayCenteredTextLine(1, "Aegis The Maze Solver");

	while (!IsBlack())
		MoveForward();
	MoveForwardTimed(500);

	DFS(&S);

	if (IsBlack()){
		displayCenteredBigTextLine(3, "BlackFound");
	}
	else if (getColorName(colorSensor) == colorBrown){
		displayCenteredBigTextLine(3, "Brown");
	}else if (getColorName(colorSensor) == colorNone){
		displayCenteredBigTextLine(3, "Cony");
	}else{
		displayCenteredBigTextLine(3, "Else");
	}

/*
	BFS(&Q);
*/

}
